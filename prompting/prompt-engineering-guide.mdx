---
title: 'Prompt Engineering Guide'
description: 'Advanced techniques for crafting effective prompts and optimizing AI interactions'
---

Master the art of prompt engineering to get the best results from AI models. This guide covers advanced techniques for structuring prompts, optimizing for different models, and maximizing the quality of AI-generated code and responses.

## Understanding AI Model Capabilities

Different AI models have different strengths and limitations. Effective prompt engineering involves adapting your communication style to leverage each model's capabilities optimally.

---

## Technology Stack Specification

### Be Explicit About Technologies

AI models work best when you clearly specify your preferred technology stack. This ensures the generated code uses the right frameworks, libraries, and architectural patterns from the start.

**Clear Stack Specification:**

```
Build a modern e-commerce dashboard using:
- React with TypeScript for the frontend
- Supabase for backend and database
- Tailwind CSS for styling
- React Query for data fetching
- React Router for navigation
```

### Recommended Technology Combinations

| Category               | Primary Choice     | Alternatives                   | Use Case                     |
| ---------------------- | ------------------ | ------------------------------ | ---------------------------- |
| **Frontend Framework** | React + TypeScript | Vue.js, Svelte, SolidJS        | Interactive web applications |
| **Styling**            | Tailwind CSS       | CSS Modules, Styled Components | Utility-first styling        |
| **Backend**            | Supabase           | Express.js, FastAPI            | Full-stack applications      |
| **State Management**   | Zustand            | Redux, Jotai                   | Complex application state    |
| **Data Fetching**      | TanStack Query     | SWR, Apollo                    | Server state management      |

### Framework-Specific Considerations

**React Applications:**

- Specify component structure (functional vs class components)
- Include state management preferences
- Define routing approach (React Router, Next.js App Router)

**Vue.js Applications:**

- Specify composition API vs options API
- Include UI library preferences (Quasar, Vuetify)
- Define build tool (Vite, Vue CLI)

**Backend Integration:**

- Specify API patterns (REST, GraphQL)
- Include authentication requirements
- Define data validation approach (Zod, Joi)

## Advanced Prompting Techniques

### Contextual Information

**Provide Relevant Context:**

- Include existing code snippets when relevant
- Reference specific files or components
- Mention current technology constraints
- Specify performance requirements

**Progressive Refinement:**

- Start with high-level requirements
- Add implementation details iteratively
- Use follow-up prompts for clarification
- Build upon previous responses

### Model-Specific Optimization

**Claude/Gemini Models:**

- Provide comprehensive context upfront
- Use structured formats (numbered lists, sections)
- Include examples and edge cases
- Specify output format preferences

**GPT Models:**

- Break complex requests into smaller parts
- Use clear, direct language
- Provide concrete examples
- Specify desired output structure

### Error Prevention

**Common Pitfalls to Avoid:**

- Vague requirements that lead to assumptions
- Missing technical specifications
- Inconsistent naming conventions
- Unspecified integration requirements

**Validation Techniques:**

- Include acceptance criteria
- Specify testing requirements
- Define success metrics
- Request validation checkpoints

<Callout type="info">
  **Version Specification**: When possible, specify framework versions to ensure compatibility and avoid deprecated
  features.
</Callout>

<Callout type="tip">
  **Iterative Refinement**: Start with a clear prompt, then use follow-up messages to add details and make adjustments
  as needed.
</Callout>

## Best Practices Summary

### Essential Prompting Principles

1. **Clarity First**: Be specific about what you want to build and how it should work
2. **Technology Specification**: Clearly state your preferred frameworks and libraries
3. **Context Provision**: Include relevant background information and constraints
4. **Iterative Approach**: Start simple, then add complexity through follow-up prompts

### Quality Checklist

**Before Submitting:**

- âœ… Goal is clearly defined
- âœ… Technology stack is specified
- âœ… Key features are listed
- âœ… User requirements are outlined
- âœ… Success criteria are defined

**During Development:**

- ðŸ”„ Provide feedback on generated code
- ðŸ”„ Request specific modifications
- ðŸ”„ Ask for explanations when needed
- ðŸ”„ Use discussion mode for planning

### Common Success Patterns

**Effective Prompts Include:**

- Specific functionality requirements
- Technology stack preferences
- User experience considerations
- Performance and scalability needs
- Integration requirements

**Ineffective Prompts Lack:**

- Clear objectives
- Technical specifications
- Implementation details
- Success criteria

<Callout type="info">
  **Remember**: The AI can only work with the information you provide. The more specific and complete your prompts, the
  better the results.
</Callout>
