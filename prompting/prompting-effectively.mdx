---
title: 'Prompt Effectively'
description: 'Master the art of clear, effective communication with AI models'
---

The quality of your results depends heavily on how clearly and effectively you communicate your intentions. CodinIT uses sophisticated system prompts that guide the AI's behavior, and understanding how to work with these prompts will help you get better results.

## Understanding AI Communication

CodinIT processes your requests through specialized system prompts that include:

- **Chain of thought reasoning**: The AI shows its thinking process before providing solutions
- **Artifact-based responses**: Code and commands are wrapped in structured artifacts
- **Context awareness**: The AI understands your project structure, running processes, and file changes
- **Search grounding**: Automatic web search for current information when needed

Effective prompting involves:

- **Clarity**: Being specific about what you want
- **Context**: Providing necessary background information (file paths, error messages, requirements)
- **Structure**: Organizing your requests logically
- **Iteration**: Refining your approach based on responses
- **Mode selection**: Using discussion mode for planning, build mode for implementation

## Example Prompts

CodinIT provides curated example prompts to help you get started:

<CardGroup cols={2}>
  <Card title="Web Development" icon="globe">
    "Create a modern React dashboard with charts and data visualization"
  </Card>
  <Card title="Mobile Apps" icon="smartphone">
    "Build a React Native expense tracker with offline storage"
  </Card>
  <Card title="APIs & Backend" icon="server">
    "Create a REST API for a blog with authentication and comments"
  </Card>
  <Card title="Full Stack" icon="layers">
    "Build a task management app with React frontend and Node.js backend"
  </Card>
</CardGroup>

These examples demonstrate effective prompting patterns that you can adapt to your specific needs.

## Core Prompting Principles

### Be Specific and Structured

**Clear Intent:**

```
❌ "Make this look better"
✅ "Add a gradient background from blue to purple, increase font size to 24px, and add 16px padding around the hero section"
```

**Provide Context:**

```
❌ "Add error handling"
✅ "Add error handling to the login form - show validation messages for empty email/password fields and API errors"
```

**Break Down Complex Tasks:**

```
❌ "Build a complete e-commerce site"
✅ "Create a product catalog component that displays items in a grid layout with images, titles, and prices"
```

### Use Progressive Enhancement

**Start Simple, Add Complexity:**

- Begin with core functionality
- Add features incrementally
- Test each addition before proceeding
- Use discussion mode for planning complex features

**Iterative Refinement:**

- Implement basic versions first
- Enhance with additional features
- Refine based on testing and feedback
- Maintain clear version control

## Leverage AI Thinking Features

### Understanding AI Reasoning

CodinIT's system prompts include chain-of-thought instructions that make the AI's reasoning visible:

**Chain of Thought (`<codinitThinking>` tags):**

- The AI shows 2-6 concrete steps it will take before implementing
- Helps you understand the approach before code is generated
- Appears at the start of every response in build mode
- Lists specific actions like "Set up Vite + React project structure" or "Implement core functionality"

**Thought Artifacts:**

- Expandable reasoning containers in the UI
- Detailed explanation of decision-making
- Visual representation of problem-solving steps
- Shows the AI's planning process transparently

This thinking process is mandatory in CodinIT's system prompts and helps ensure the AI takes a systematic approach to your requests.

### Using Discussion Mode Effectively

**Planning Phase:**

- Click the "Discuss" button to activate discussion mode
- The AI switches to a specialized consultant prompt
- Get guidance without code implementation
- Receive plans with numbered steps in plain English
- Explore multiple solution approaches with reasoning
- Understand trade-offs and implications

**Implementation Phase:**

- Click "Implement this plan" quick action button
- Automatically switches to build mode with context
- The AI generates code based on the discussed plan
- Reference discussion insights in follow-up prompts
- Iterate based on discussion feedback

**Key Differences:**

- **Discussion mode**: Plans in plain English, no code snippets, consultative tone
- **Build mode**: Generates code in artifacts, implements features, shows chain of thought

## Optimizing for Different AI Models

### Understanding Model Capabilities

CodinIT supports multiple AI providers through its provider system. Different models have different strengths:

**Claude (Anthropic):**

- Excellent at reasoning and analysis
- Strong code generation capabilities
- Good for complex problem-solving
- Works well with CodinIT's chain-of-thought prompting
- Larger context windows for bigger projects

**GPT Models (OpenAI):**

- Fast and versatile
- Good for creative tasks
- Strong at following detailed instructions
- Cost-effective for simpler tasks

**Other Models (DeepSeek, Gemini, Groq, etc.):**

- Specialized capabilities vary by provider
- Consider context limits and pricing
- Test different models for your use case
- Some excel at specific tasks (e.g., DeepSeek for code)

### Prompt Library Options

CodinIT offers three system prompt variants:

1. **Default Prompt**: Battle-tested standard prompt with comprehensive guidelines
2. **Fine-Tuned Prompt**: Optimized for better results with advanced techniques
3. **Experimental Prompt**: Optimized for lower token usage (experimental)

You can select these in the settings to optimize for your needs.

### Adapting Your Prompts

**Model-Specific Approaches:**

- Adjust complexity based on model capabilities
- Use different prompting styles for different models
- Consider model context windows when structuring requests
- Optimize for speed vs. quality based on your needs

## Best Practices Summary

### Communication Strategies

**Clear and Concise:**

- State your goal upfront
- Provide specific requirements
- Include relevant context
- Avoid ambiguous language

**Structured Requests:**

- Break complex tasks into steps
- Use numbered lists for multi-part requests
- Specify file locations when relevant
- Include examples when helpful

**Iterative Approach:**

- Start with core functionality
- Add features incrementally
- Test and refine as you go
- Use discussion mode for planning

### Model-Aware Prompting

**Context Awareness:**

- Consider model context limits
- Provide necessary background information
- Reference existing code when relevant
- Be mindful of token usage

**Quality vs. Speed:**

- Use larger models for complex tasks
- Choose faster models for simple iterations
- Balance cost and performance needs
- Optimize prompts for your chosen model

<Callout type="info">
  **Continuous Learning**: Effective prompting improves with practice. Pay attention to what works well and refine your
  approach over time.
</Callout>

<Callout type="tip">
  **Start Simple**: Begin with clear, straightforward prompts and add complexity as you become more comfortable with the
  system.
</Callout>

```txt theme={"system"}
For all designs I ask you to make, have them be beautiful, not cookie cutter. Make webpages that are fully featured and worthy for production.

By default, this template supports JSX syntax with Tailwind CSS classes, the shadcn/ui library, React hooks, and Lucide React for icons. Do not install other packages for UI themes, icons, etc unless absolutely necessary or I request them.

Use icons from lucide-react for logos.

Use stock photos from unsplash where appropriate.
```

### Tips for the project or system prompts

- Include instructions to CodinIT.dev to only change relevant code.
